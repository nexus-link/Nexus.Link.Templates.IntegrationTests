@using SharedKernel
@{
    ViewData["Title"] = "Events";

    // TODO: Lista på senast körda
    // TODO: Kunna avbryta
    // TODO: Local storage för vilka tester som körts/är aktiv

    // TODO: Spinner när man klickar på knappen
    // TODO: disabled knapp medan testet kör? eller skapas ett nytt bara?
    // TODO: när man klickat på en "nav-*", inte kunna klicka igen tills den är klar
}

<div>
    <button class="button is-primary" onclick="Tests.start()">Start test</button>
</div>

<div id="tests"></div>

<script src="~/js/signalr/dist/browser/signalr.min.js"></script>

<script>
    $ = (selector) => {
        const result = document.querySelectorAll(selector);
        if (result.length === 0) return null;
        if (result.length === 1) return result[0];
        return Array.from(result);
    }

    const TestsRenderer = (() => {

        const buildTestPath = (test, activeTestId, path) => {
            path.push(test);
            if (test.Id === activeTestId) return true;
            if (!test.Children) return false;
            let found = false;
            test.Children.forEach((child) => {
                const pathContainsActive = buildTestPath(child, activeTestId, path);
                if (pathContainsActive) found = true;
                else path.pop();
            });
            return found;
        }

        const getParent = (test, activeTestId, parent) => {
            if (test.Id === activeTestId) return parent;
            if (!test.Children) return null;
            for (const child of test.Children) {
                const x = getParent(child, activeTestId, test);
                if (x) return x;
            }
            return null;
        }

        const setupEventListeners = (eventListeners) => {
            eventListeners.forEach((ev) => {
                $(`#${ev.elementId}`).addEventListener(ev.event, ev.func);
            });
        }

        const navigateTo = (rootTest, activeTest) => {
            // ReSharper disable once VariableUsedInInnerScopeBeforeDeclared
            const navSetup = createNav(rootTest, activeTest);
            $(`#nav-render-${rootTest.Id}`).innerHTML = navSetup.html;
            setupEventListeners(navSetup.eventListeners);
        }

        const createAPanel = (elementId, name, state) => {
            const iconClass = state === "@StateEnum.Ok" ? "fa-check has-text-success-dark" : (state === "@StateEnum.Failed" ? "fa-times has-text-danger-dark" : "fa-spinner fa-spin has-text-info");
            return `<a class="panel-block is-flex" id="${elementId}">` +
                `  <span class="panel-icon is-flex is-flex-grow-0"><i class="fas fa-vial" aria-hidden="true"></i></span>` +
                `  <span class="is-flex is-flex-grow-2">${name}</span>` +
                `  <span class="text-right is-flex is-flex-grow-0 is-justify-content-center" style="width:2rem"><i class="fas ${iconClass}"></i></span>` +
                `</a>`;
        }

        const createNav = (rootTest, test) => {
            const eventListeners = [];
            let html = '<div class="panel-block">' +
                '  <nav class="breadcrumb" aria-label="breadcrumbs">' +
                '    <ul>';

            // Bread crumbs
            const breadCrumbs = [];
            if (!buildTestPath(rootTest, test.Id, breadCrumbs)) throw `Unable to find bread crumbs for test ${test.Id} in test ${rootTest.Id}`;
            breadCrumbs.forEach((crumb) => {
                const aElementId = `crumb-${crumb.Id}`;
                eventListeners.push({ elementId: aElementId, event: "click", func: (event) => { event.preventDefault(); navigateTo(rootTest, crumb); } });
                html += `<li><a id="${aElementId}">${crumb.Name}</a></li>`;
            });
            html += '  </ul>' +
                '  </nav>' +
                '</div>';
            if (rootTest.Id !== test.Id) {
                const parent = getParent(rootTest, test.Id);
                const aElementId = `nav-${parent.Id}`;
                html += createAPanel(aElementId, "..", parent.State);
                eventListeners.push({ elementId: aElementId, event: "click", func: (event) => { event.preventDefault(); navigateTo(rootTest, parent); } });
            }
            if (test.Children) {
                test.Children.forEach((child) => {
                    const aElementId = `nav-${child.Id}`;
                    html += createAPanel(aElementId, child.Name, child.State);
                    eventListeners.push({ elementId: aElementId, event: "click", func: (event) => { event.preventDefault(); navigateTo(rootTest, child); } });
                });
            }
            return { html: html, eventListeners: eventListeners };
        }

        return {
            maybeFullRender: (rootTest) => {
                const elementId = `test-${rootTest.Id}`;
                if (document.querySelector(`#${elementId}`)) return;

                let html = `<div id="${elementId}">` +
                    '<nav class="panel">' +
                    '<p class="panel-heading">' +
                    '  Test result' +
                    '</p>' +
                    '<div class="panel-block">' +
                    `  <progress id="progress-${rootTest.Id}" class="progress" value="0" max="100"></progress>` +
                    '</div>' +
                    '<div class="panel-block">' +
                    '  <p class="control has-icons-left">' +
                    '    <input class="input" type="text" placeholder="Search">' +
                    '    <span class="icon is-left"><i class="fas fa-search" aria-hidden="true"></i></span>' +
                    '  </p>' +
                    '</div>' +
                    `<div id="nav-render-${rootTest.Id}">`;

                const navSetup = createNav(rootTest, rootTest);
                html += navSetup.html;

                html += "</div>";
                html += '</nav>';

                html += "</div>";
                const testElement = document.createElement("div");
                testElement.setAttribute("id", elementId);
                testElement.innerHTML = html;
                $("#tests").append(testElement);

                setupEventListeners(navSetup.eventListeners);
            }
        }
    })();

    const Tests = (() => {
        // SignalR
        var connection = new window.signalR.HubConnectionBuilder().withUrl("/testsHub").build();
        connection.start().then(() => { }).catch((err) => { return console.error("Connection error", err.toString()); });

        // Helper: Progress
        const setProgressValue = (testId, value) => {
            const progressElement = $(`#progress-${testId}`);
            if (progressElement) progressElement.setAttribute("value", value);
        }

        // Polling
        let activeIntervals = [],
            pollingEndsAt = [];
        const pollingInterval = 1000,
            maxPollSeconds = 3; // TODO: 120?

        const endPoll = (testId) => {
            clearInterval(activeIntervals[testId]);
            pollingEndsAt[testId] = null;
        };
        const poll = (testId, endPollingAt) => {
            pollingEndsAt[testId] = endPollingAt;
            activeIntervals[testId] = setInterval(function () {
                if (!activeIntervals[testId] || !pollingEndsAt[testId] || new Date > pollingEndsAt[testId]) {
                    endPoll(testId);
                }
                console.log("pinging");
                connection.invoke("UpdateStatus", testId);

                let secondsLeft = (endPollingAt.getTime() - (new Date).getTime()) / 1000;
                if (secondsLeft < 0) secondsLeft = 0;
                //$(`#progress-${testId}`).classList.remove("is-hidden");
                setProgressValue(testId, 100 - Math.ceil(100 * secondsLeft / maxPollSeconds));

            }, pollingInterval);
        };

        // Helper: Storage
        const getStoredTests = () => {
            const testContextsString = sessionStorage.getItem("testContexts");
            if (!testContextsString) return null;
            return JSON.parse(testContextsString);
        }

        const addStoredTest = (testId, endPollingAt) => {
            let testContexts = getStoredTests();
            if (!testContexts) testContexts = [];
            testContexts.push({ testId: testId, endPollingAt: endPollingAt });
            sessionStorage.setItem("testContexts", JSON.stringify(testContexts));
        }


        // Rendering

        const renderTest = (test) => {
            TestsRenderer.maybeFullRender(test, test.Id);

            // TODO: update state
        }

        // Events
        const testChanged = (test) => {
            console.log("TestChanged", test);
            renderTest(test);
        };
        connection.on("TestChanged", testChanged);

        // Helper: Call dashboard API
        const callApi = (method, url, callbacks) => {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState !== 4) return;
                if (xhr.status >= 200 && xhr.status < 300) {
                    if (callbacks && callbacks.ok) callbacks.ok(xhr);
                } else {
                    if (callbacks && callbacks.error) callbacks.error(xhr);
                }
                if (callbacks && callbacks.always) callbacks.always(xhr);
            };
            xhr.open(method, url);
            xhr.send();
        }

        // Exposed methods
        return {
            maybeResume: () => {
                const testContexts = getStoredTests();
                console.log(testContexts);
                if (!testContexts) return;
                testContexts.forEach((testContext) => {
                    const endTime = new Date(testContext.endPollingAt);
                    if (new Date < endTime) {
                        poll(testContext.testId, endTime);
                    }
                });
            },

            start: () => {
                // Start the test. A callback on "TestChanged" will happen.
                callApi("POST", "/api/Tests/Start",
                    {
                        ok: (xhr) => {
                            const testId = xhr.response;
                            const endPollingAt = new Date((new Date).getTime() + maxPollSeconds * 1000);
                            poll(testId, endPollingAt);
                            addStoredTest(testId, endPollingAt);
                        },
                        error: (xhr) => { console.log("error", xhr.status, xhr.responseText); }
                    });
            }
        }
    })();

    Tests.maybeResume();
</script>